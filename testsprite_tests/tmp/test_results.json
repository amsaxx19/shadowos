[
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "4bd2195b-cfca-482c-a4d1-9090c8f4c15c",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC001-Passwordless OTP Authentication - Successful Login",
    "description": "Verify that a user can successfully authenticate using a valid email and correct OTP code.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Log in' link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click on the 'Log in' link to go to the login page.\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter the registered valid email address amosthiosa1999@gmail.com in the email input field.\n        frame = context.pages[-1]\n        # Enter the registered valid email address amosthiosa1999@gmail.com in the email input field.\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        # -> Click the 'Continue' button to request the OTP code.\n        frame = context.pages[-1]\n        # Click the 'Continue' button to request the OTP code.\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter the OTP code 123456 into the OTP input field.\n        frame = context.pages[-1]\n        # Enter the correct OTP code 123456 into the OTP input field.\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Confirm the presence of dashboard elements or welcome message to verify successful login.\n        frame = context.pages[-1]\n        # Click the 'Continue' button on the dashboard create page to proceed further and confirm login success.\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Which model best describes your offer?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Coaching and courses').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Agency services').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Paid group').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Software').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Events').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Newsletter').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Physical products').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Brick and mortar').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099488627273//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.205Z",
    "modified": "2025-12-07T09:24:48.784Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "9993fb57-3446-4900-adb9-fd00aa6b1e10",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC002-Passwordless OTP Authentication - Login with Mock OTP for Test Domain",
    "description": "Verify login works for emails ending with @example.com using the fixed mock OTP 123456.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Log in' link to navigate to the login page\n        frame = context.pages[-1]\n        # Click on the 'Log in' link to go to the login page\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter email amosthiosa1999@example.com in the email input field\n        frame = context.pages[-1]\n        # Enter email ending with @example.com for OTP test\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@example.com')\n        \n\n        # -> Click the Continue button to request OTP\n        frame = context.pages[-1]\n        # Click the Continue button to request OTP\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter the mock OTP code 123456 into the OTP input field\n        frame = context.pages[-1]\n        # Enter the mock OTP code 123456 into the OTP input field\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Let\\'s create your business').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Businesses on CUANBOSS earn over Rp 10 billion every year.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Let\\'s build yours now.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Continue').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099468117277//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.212Z",
    "modified": "2025-12-07T09:24:28.308Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "30d1db3a-0d31-4821-a2ec-91310ba09f4c",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC003-Passwordless OTP Authentication - Incorrect OTP",
    "description": "Ensure login fails when the user enters an incorrect OTP code.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Log in' link to navigate to the login page\n        frame = context.pages[-1]\n        # Click on the 'Log in' link to go to the login page\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter the registered valid email address 'amosthiosa1999@gmail.com' and click Continue to request OTP\n        frame = context.pages[-1]\n        # Enter registered valid email address\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to request OTP\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter an incorrect OTP code and submit it to verify login failure and error message\n        frame = context.pages[-1]\n        # Enter an incorrect OTP code\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        # Click the button to submit the OTP code (Kirim ulang kode) or find the submit button if different\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter an incorrect OTP code '000000' into the input and submit it to verify login failure and error message\n        frame = context.pages[-1]\n        # Enter an incorrect OTP code\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('000000')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Kirim ulang kode' button or find the submit button if different to submit the OTP code\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Verify your login').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=We sent a verification code to amosthiosa1999@gmail.com. Enter the 6-digit code below.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Kirim ulang dalam 38s').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Use a different email').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099509030498//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.221Z",
    "modified": "2025-12-07T09:25:09.194Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "b0186bd0-587a-48de-b487-6e41b4e01701",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC004-Dual Dashboards - Operator View Data Accuracy",
    "description": "Verify that the Operator dashboard correctly displays global statistics, product lists, orders, and operator wallet balance.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Retry loading the login page with the correct URL or check connectivity.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input the email amosthiosa1999@gmail.com and click Continue to proceed with login.\n        frame = context.pages[-1]\n        # Input the Shadow Operator email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the OTP code '123456' into the verification input field to complete login and access the Operator dashboard.\n        frame = context.pages[-1]\n        # Input the OTP code to verify login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        frame = context.pages[-1]\n        # Click the button to submit OTP and proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Continue button to proceed from the business creation prompt towards the Operator dashboard.\n        frame = context.pages[-1]\n        # Click Continue button on business creation prompt to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a business model option to continue the business creation flow towards accessing the Operator dashboard.\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the business model to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an industry option to continue the business creation flow towards accessing the Operator dashboard.\n        frame = context.pages[-1]\n        # Select 'Ecommerce' industry option to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click the 'Create business' button to proceed towards the Operator dashboard.\n        frame = context.pages[-1]\n        # Input a business name to enable the 'Create business' button\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Create business' button to complete business creation step\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Create business' button to complete the business creation step and navigate to the Operator dashboard.\n        frame = context.pages[-1]\n        # Click 'Create business' button to complete business creation and proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Operator Wallet Balance Exceeds Limit').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Operator dashboard did not correctly display global statistics, product lists, orders, or operator wallet balance as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify the Operator dashboard could not be completed because after business creation, the application redirected back to the login screen unexpectedly. This prevents access to the dashboard and verification of required elements. Please fix the issue and retry.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/CuanBoss_shadowos_app_favicon_ico_mjs_844ea004._.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/__nextjs_font/geist-mono-latin.woff2:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099562256759//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.228Z",
    "modified": "2025-12-07T09:26:02.450Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "5e731f65-5979-4920-bf95-1fbe39d010db",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC005-Dual Dashboards - Creator View Data Accuracy",
    "description": "Verify that the Creator dashboard correctly displays personal sales, product lists, orders, and wallet information.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start login process as Creator user.\n        frame = context.pages[-1]\n        # Click on 'Log in' to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email amosthiosa1999@gmail.com and click Continue to proceed with login.\n        frame = context.pages[-1]\n        # Input Creator user email\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP 123456 and submit to complete login and reach Creator dashboard.\n        frame = context.pages[-1]\n        # Input OTP code 123456\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        frame = context.pages[-1]\n        # Click resend code button (if needed) or submit OTP if possible\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Continue button to proceed to the Creator dashboard or next step.\n        frame = context.pages[-1]\n        # Click Continue button on business creation prompt to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the offer model that best describes the Creator's products to proceed towards dashboard access.\n        frame = context.pages[-1]\n        # Select 'Physical products' as the offer model to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an industry that best describes the Creator's offer to proceed towards dashboard access.\n        frame = context.pages[-1]\n        # Select 'Ecommerce' industry as it is relevant to Creator's products\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' to proceed towards Creator dashboard.\n        frame = context.pages[-1]\n        # Input business name for Creator business\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Creator Business')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard Overview').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Creator dashboard did not display the expected personal sales, product lists, orders, or wallet information as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to proceed past the business creation step. The 'Create business' button does not function as expected, blocking access to the Creator dashboard. Issue reported for developer investigation.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/videos/tech_poster.jpg:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099566186492//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.235Z",
    "modified": "2025-12-07T09:26:06.364Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "f50cd83c-b1b3-4ff1-bcde-51b76c747cf4",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC006-Product Creation with Digital Asset Upload",
    "description": "Validate successful creation of a new product including uploading images or files to Supabase Storage.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start login process\n        frame = context.pages[-1]\n        # Click on 'Log in' to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email amosthiosa1999@gmail.com and click Continue\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Continue' button to proceed to product details form\n        frame = context.pages[-1]\n        # Click 'Continue' button to proceed to product details form\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Physical products' as the model for the new product\n        frame = context.pages[-1]\n        # Select 'Physical products' as the product model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Ecommerce' as the industry for the new product\n        frame = context.pages[-1]\n        # Select 'Ecommerce' as the industry\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' button to proceed\n        frame = context.pages[-1]\n        # Input business name\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Create business' button to proceed to next step\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Product Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The product creation process did not complete successfully, or the product does not appear on the product list as expected. Uploaded media files may also be missing or inaccessible in Supabase Storage.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical issue: After clicking 'Create business', the page redirected to login screen unexpectedly, preventing completion of product creation and media upload validation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099599685209//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.242Z",
    "modified": "2025-12-07T09:26:39.824Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "bb2c0480-7a3a-4485-8473-96acf886e305",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC007-Product Editing and Media Replacement",
    "description": "Verify that product editing works correctly including updating media files and saving changes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start login process\n        frame = context.pages[-1]\n        # Click on 'Log in' to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email amosthiosa1999@gmail.com and click Continue\n        frame = context.pages[-1]\n        # Input email amosthiosa1999@gmail.com\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Continue' button to proceed from business creation prompt and find navigation to product management or product edit page.\n        frame = context.pages[-1]\n        # Click 'Continue' button on business creation prompt page\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Physical products' as the offer model to proceed towards product management and editing.\n        frame = context.pages[-1]\n        # Select 'Physical products' as the offer model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Ecommerce' industry to continue towards product management and editing.\n        frame = context.pages[-1]\n        # Select 'Ecommerce' industry\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' button to proceed to dashboard or product management.\n        frame = context.pages[-1]\n        # Input business name 'Test Business'\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to create the business and proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Product update successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan failed: Product editing did not work correctly including updating media files and saving changes.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to a blocking issue: The 'Create business' button on the business naming page does not function correctly, preventing access to product management and product editing features. Please fix this issue to enable further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/videos/tech_poster.jpg:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_65707185._.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/00eec_next_dist_compiled_next-devtools_index_cf174563.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099573898671//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.250Z",
    "modified": "2025-12-07T09:26:14.046Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "19651c1e-98e5-4135-8e4d-ead1fa4fa446",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC008-Landing Page Rendering and UI Components",
    "description": "Check that the landing page loads correctly and all UI components such as hero section, search bar with live suggestions, trending products, and category grid with video backgrounds are displayed properly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Test the search bar live suggestions by typing a query to verify suggestions appear.\n        frame = context.pages[-1]\n        # Type 'test' in the search bar to check live suggestions\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('test')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=⚡').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Log in').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Mulai Jualan').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=View Trends').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Lihat Tren').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Belajar Saham').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tips Affiliate').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Cara FYP TikTok').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Ide Bisnis 2025').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tutorial Coding').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Diet Sehat').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Investasi Pemula').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=⚡').nth(1)).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CUANBOSS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=The operating system for digital entrepreneurs').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=⌘K').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Clipping').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Trading').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bisnis').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Karir').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Teknologi').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Lifestyle').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099501641239//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.256Z",
    "modified": "2025-12-07T09:25:01.813Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "e6384a03-af54-44f8-b851-34973feae1ce",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC009-Discover & Search - Live Suggestions Accuracy and Performance",
    "description": "Validate the discover and search page returns relevant live product suggestions with minimal latency as user types in the search bar.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Type a partial product name or keyword in the search bar to trigger live search suggestions\n        frame = context.pages[-1]\n        # Type partial product name 'clip' in the search bar to trigger live search suggestions\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('clip')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Clipping agennnn').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Clipping').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099458755175//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.263Z",
    "modified": "2025-12-07T09:24:18.932Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "826ee473-e6d5-4eca-a8f6-4ccf982d0876",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC010-Order Processing and Automatic Revenue Split",
    "description": "Ensure that purchasing an order properly processes payment and splits revenue automatically between Operator and Creator wallets as per configured percentages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start customer login process\n        frame = context.pages[-1]\n        # Click on 'Log in' link to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email amosthiosa1999@gmail.com and click Continue\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP 123456 and submit to complete login\n        frame = context.pages[-1]\n        # Input OTP code 123456 for verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Submit the OTP code to complete login and access the dashboard\n        frame = context.pages[-1]\n        # Submit OTP code by clicking the verification submit or confirm element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Skip or bypass the business model selection to reach the dashboard or product browsing page to select a product linked to Operator and Creator for purchase.\n        frame = context.pages[-1]\n        # Click on the first business model option 'Coaching and courses' to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Revenue Split Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Purchasing an order did not properly process payment and split revenue between Operator and Creator wallets as per configured percentages.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to bypass business creation page after login. The user cannot proceed to dashboard or product browsing to select a product for purchase. This blocks the completion of the task to verify payment processing and revenue split between Operator and Creator wallets.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099534368581//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.269Z",
    "modified": "2025-12-07T09:25:34.523Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "5dd0f7bf-b84c-468c-b5bf-f02d1b55b116",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC011-Wallet Transaction History Completeness",
    "description": "Verify that all financial activities including sales income and withdrawals are reflected comprehensively and accurately in the wallet transaction history.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start login process.\n        frame = context.pages[-1]\n        # Click on 'Log in' link to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email amosthiosa1999@gmail.com and click Continue.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP 123456 and submit to complete login.\n        frame = context.pages[-1]\n        # Input OTP 123456 for login verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Click the 'Continue' button to proceed to the main dashboard page.\n        frame = context.pages[-1]\n        # Click 'Continue' button on business creation prompt page\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an offer model to proceed further in the business creation process.\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the offer model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an industry to proceed further in the business creation process.\n        frame = context.pages[-1]\n        # Select 'Ecommerce' as the industry that best describes the offer\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' to proceed.\n        frame = context.pages[-1]\n        # Input business name\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Create business' button to complete the business creation process and proceed to the dashboard.\n        frame = context.pages[-1]\n        # Click 'Create business' button to complete business creation and proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All transactions are perfectly reconciled and verified').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Wallet transaction history does not comprehensively and accurately reflect all financial activities including sales income and withdrawals as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to unexpected redirect to login page after business creation. Unable to verify wallet transaction history as required.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099620550118//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.277Z",
    "modified": "2025-12-07T09:27:00.722Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "95403266-2e0e-43d9-bdcc-a405752b53f1",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC012-Wallet Withdrawal Request Flow",
    "description": "Validate that users can successfully submit withdrawal requests and that wallet balances and transaction histories reflect the withdrawal.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start login process.\n        frame = context.pages[-1]\n        # Click on 'Log in' link to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email amosthiosa1999@gmail.com and click Continue.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Continue' button to proceed to the main dashboard or next page where wallet withdrawal request page can be accessed.\n        frame = context.pages[-1]\n        # Click 'Continue' button on business creation prompt page\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an offer model to proceed further towards accessing the main dashboard or wallet withdrawal request page.\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the offer model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an industry to proceed further towards accessing the main dashboard or wallet withdrawal request page.\n        frame = context.pages[-1]\n        # Select 'Ecommerce' industry as it is a common choice\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' to proceed to the main dashboard or next page.\n        frame = context.pages[-1]\n        # Input business name\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Withdrawal Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Withdrawal request submission failed or wallet balance and transaction history did not update as expected according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to proceed past the business creation step. The 'Create business' button does not navigate or show success, blocking access to wallet withdrawal request page and preventing withdrawal request tests.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099553036874//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.285Z",
    "modified": "2025-12-07T09:25:53.230Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "49f9152c-c6ec-409a-acce-7e6df2854f7f",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC013-Route Protection Middleware - Unauthorized Access",
    "description": "Ensure that the middleware correctly blocks access to protected routes for unauthenticated users.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Welcome to the Secret Admin Panel').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: Middleware did not block access to protected routes for unauthenticated users as expected. User was not redirected to the login page.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:3000/\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/176509924569977//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.293Z",
    "modified": "2025-12-07T09:20:45.855Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "3695e6ef-2964-46cc-b852-ec4fad549474",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC014-Route Protection Middleware - Session Integrity for Authenticated User",
    "description": "Verify that authenticated users maintain session integrity and can access protected routes without interruption.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'Log in' link to start the login process.\n        frame = context.pages[-1]\n        # Click on the 'Log in' link to start login\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the test email amosthiosa1999@gmail.com and click Continue.\n        frame = context.pages[-1]\n        # Input the test email amosthiosa1999@gmail.com\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP 123456 into the verification input field.\n        frame = context.pages[-1]\n        # Input the OTP code 123456 for verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Click the 'Continue' button to proceed further in the dashboard flow.\n        frame = context.pages[-1]\n        # Click the 'Continue' button on the dashboard create page to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the 'Coaching and courses' offer model by clicking the corresponding button.\n        frame = context.pages[-1]\n        # Select the 'Coaching and courses' offer model to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the 'Ecommerce' industry by clicking the corresponding button (index 6).\n        frame = context.pages[-1]\n        # Select the 'Ecommerce' industry to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click the 'Create business' button to proceed.\n        frame = context.pages[-1]\n        # Input a business name 'Test Business'\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        # -> Click the 'Create business' button to complete the business creation step and proceed.\n        frame = context.pages[-1]\n        # Click the 'Create business' button to complete business creation\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Session Timeout Error').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Authenticated users did not maintain session integrity and could not access protected routes without interruption as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Session integrity test failed. After successful login and progressing through dashboard steps, the session was lost after submitting the business creation form, redirecting to the login page. This indicates a critical issue with session management. Further testing of protected routes is not possible until this is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_65707185._.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/00eec_next_dist_compiled_next-devtools_index_cf174563.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099595927718//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.301Z",
    "modified": "2025-12-07T09:26:36.105Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "5d653abc-de03-4c8a-8186-891bda627b35",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC015-Middleware Rate Limiting Disabled Behavior",
    "description": "Validate that the rate limiting middleware is currently disabled and does not restrict normal API/request traffic.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start the login process.\n        frame = context.pages[-1]\n        # Click on 'Log in' link to go to login page\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email 'amosthiosa1999@gmail.com' and click Continue.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP code '123456' and submit to complete login.\n        frame = context.pages[-1]\n        # Input OTP code for verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Make multiple rapid requests to controlled API endpoints to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Click 'Continue' to proceed from dashboard create page\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Make multiple rapid requests to controlled API endpoints to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the offer model to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Make multiple rapid requests to controlled API endpoints to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Select 'Trading' industry to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Make multiple rapid requests to controlled API endpoints to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Input business name to enable Create business button\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestBusiness')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Create business' button to proceed and then start making multiple rapid API requests to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Perform login again using provided credentials to regain session and then proceed with rate limiting test.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP code '123456' and submit to complete login.\n        frame = context.pages[-1]\n        # Input OTP code for verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Make multiple rapid requests to controlled API endpoints to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Click 'Continue' button to proceed with business creation flow\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Coaching and courses' as the offer model to proceed and then start making multiple rapid API requests to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the offer model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Trading' industry to proceed and then start making multiple rapid API requests to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Select 'Trading' industry to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name to enable the 'Create business' button, then create the business and proceed to make multiple rapid API requests to verify no rate limiting occurs.\n        frame = context.pages[-1]\n        # Input business name to enable 'Create business' button\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestBusiness')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rate limit exceeded').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Rate limiting middleware is expected to be disabled, but 'Rate limit exceeded' message was not found, indicating the test plan execution has failed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The user successfully logged in and navigated through the business creation flow up to the business naming page. The rate limiting middleware validation by making multiple rapid API requests was planned but not executed. Therefore, the rate limiting middleware status could not be fully validated. Task stopped as requested.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/00eec_next_dist_compiled_417831a2._.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099697283514//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.309Z",
    "modified": "2025-12-07T09:28:17.467Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "e0130cfd-7386-4dc2-b023-6521562123a4",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC016-Sell Page Rendering and CTA Functionality",
    "description": "Check that the marketing Sell page loads correctly with hero section, benefits, testimonials, FAQ, and functioning CTA buttons.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Mulai Jualan' button to navigate to the Sell page.\n        frame = context.pages[-1]\n        # Click 'Mulai Jualan' button to navigate to the Sell page\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to locate and verify the benefits section content.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down further to locate and verify the testimonials section.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down further to locate and verify the testimonials section.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down further to locate and verify the testimonials section.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down to locate and verify the testimonials section.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down further to locate and verify the testimonials section.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll down or extract content to locate and verify the testimonials section.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Click the CTA button 'Buat Akun Gratis' to verify navigation to signup/login page.\n        frame = context.pages[-1]\n        # Click the CTA button 'Buat Akun Gratis' to navigate to signup/login page\n        elem = frame.locator('xpath=html/body/div[2]/section[6]/div/div/div[2]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test email 'amosthiosa1999@gmail.com' and click 'Continue' to proceed with login.\n        frame = context.pages[-1]\n        # Input test email for signup/login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click 'Continue' button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Sign in' link to navigate to the login page for entering OTP.\n        frame = context.pages[-1]\n        # Click 'Sign in' link to navigate to login page for OTP entry\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test email 'amosthiosa1999@gmail.com' and click 'Continue' to proceed to OTP verification.\n        frame = context.pages[-1]\n        # Input test email for OTP login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click 'Continue' button to proceed to OTP verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input OTP code '123456' into the 6-digit code input field to verify login.\n        frame = context.pages[-1]\n        # Input OTP code for login verification\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123456')\n        \n\n        # -> Click the 'Continue' button on the dashboard create page to proceed.\n        frame = context.pages[-1]\n        # Click 'Continue' button on dashboard create page to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Which model best describes your offer?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Coaching and courses').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Agency services').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Paid group').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Software').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Events').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Newsletter').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Physical products').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Brick and mortar').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099636671549//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.317Z",
    "modified": "2025-12-07T09:27:16.842Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "5e592397-256f-4775-b697-ece37c803a9d",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC017-Search Suggestions - Edge Case Nonexistent Query",
    "description": "Validate the behavior of live search suggestions when user inputs query with no matching products.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter a random string or nonexistent product name in the search bar to test live search suggestions for no matches\n        frame = context.pages[-1]\n        # Enter a random string or nonexistent product name in the search bar to test live search suggestions for no matches\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('nonexistentproductxyz')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Verify no suggestions are shown and UI handles empty state smoothly\n        # Since no matching product, no suggestion text from PAGE TEXT should appear\n        # Check that none of the known product suggestion texts are visible\n        suggestion_texts = [\"Mulai Jualan\", \"View Trends\", \"Lihat Tren\", \"Belajar Saham\", \"Tips Affiliate\", \"Cara FYP TikTok\", \"Ide Bisnis 2025\", \"Tutorial Coding\", \"Diet Sehat\", \"Investasi Pemula\"]\n        for text in suggestion_texts:\n            await expect(frame.locator(f'text={text}').first).not_to_be_visible(timeout=3000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099448220319//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.326Z",
    "modified": "2025-12-07T09:24:08.377Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "d31367d8-7c1b-4492-a48f-6668889d9193",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC018-Product Management - Invalid Media Upload Handling",
    "description": "Ensure the product creation/editing workflow handles invalid media file uploads gracefully with proper error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Upload Successful! Your media file is valid.').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The product creation/editing workflow did not handle invalid media file uploads gracefully. The system did not reject the unsupported or corrupted media file with an appropriate error message, or the submission was not blocked as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:3000/\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099246419403//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.334Z",
    "modified": "2025-12-07T09:20:46.543Z"
  },
  {
    "projectId": "ba381708-3112-4b63-876c-d8a5722193a5",
    "testId": "d50c831a-79e7-4562-9913-450029d1e98a",
    "userId": "6448a4e8-c071-70c9-3157-376769218e6e",
    "title": "TC019-Order Processing - Insufficient Payment Handling",
    "description": "Verify that orders fail gracefully if payment processing is incomplete or insufficient.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Log in' to start login process\n        frame = context.pages[-1]\n        # Click on 'Log in' to start login process\n        elem = frame.locator('xpath=html/body/div[2]/nav/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test email amosthiosa1999@gmail.com and click Continue\n        frame = context.pages[-1]\n        # Input test email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Continue' to proceed with business creation and access purchase/order flow\n        frame = context.pages[-1]\n        # Click 'Continue' button to proceed with business creation\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an offer model to proceed with business creation\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the offer model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an industry to proceed with business creation\n        frame = context.pages[-1]\n        # Select 'Ecommerce' industry to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' to proceed\n        frame = context.pages[-1]\n        # Input business name 'Test Business'\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Create business' button to complete business creation and proceed\n        frame = context.pages[-1]\n        # Click 'Create business' button to complete business creation\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test email amosthiosa1999@gmail.com and click Continue to login\n        frame = context.pages[-1]\n        # Input test email for login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('amosthiosa1999@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Continue' button to proceed with business creation\n        frame = context.pages[-1]\n        # Click 'Continue' button to proceed with business creation\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Coaching and courses' as the offer model to proceed\n        frame = context.pages[-1]\n        # Select 'Coaching and courses' as the offer model\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an industry to proceed with business creation\n        frame = context.pages[-1]\n        # Select 'Ecommerce' industry to proceed\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a business name and click 'Create business' to proceed\n        frame = context.pages[-1]\n        # Input business name 'Test Business Final'\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business Final')\n        \n\n        frame = context.pages[-1]\n        # Click 'Create business' button to complete business creation\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/div[2]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Order Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The order did not fail gracefully as expected. Payment processing was incomplete or insufficient, but the order confirmation message 'Order Completed Successfully' was not expected to appear.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify that orders fail gracefully if payment processing is incomplete or insufficient is not fully completed because the purchase initiation and payment failure simulation steps were not reached or executed. The login and business creation flows were successfully completed using the test credentials, and the system navigated correctly through all steps up to the business naming and creation page. However, the critical steps to initiate a purchase, simulate payment failure or insufficient funds, verify that the order is not confirmed, check for meaningful error messages, and confirm wallet balances remain unchanged were not performed. Therefore, the task is only partially done and requires further steps to fully verify the payment failure handling.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6448a4e8-c071-70c9-3157-376769218e6e/1765099659631893//tmp/test_task/result.webm",
    "created": "2025-12-07T09:20:16.342Z",
    "modified": "2025-12-07T09:27:39.763Z"
  }
]
